var searchIndex = JSON.parse('{\
"erased_cells":{"doc":"Encoding and manipulation of runtime-dynamic cell values.","t":"EDIEENNNNNNNNNNNNNNNNNNNNNNNNNNNNNNLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLALLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLOLLENNNGLLLLLLLLLLMM","n":["CellBuffer","CellBufferIterator","CellEncoding","CellType","CellValue","Float32","Float32","Float32","Float64","Float64","Float64","Int16","Int16","Int16","Int32","Int32","Int32","Int64","Int64","Int64","Int8","Int8","Int8","UInt16","UInt16","UInt16","UInt32","UInt32","UInt32","UInt64","UInt64","UInt64","UInt8","UInt8","UInt8","add","add","add","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","can_fit_into","cell_type","cell_type","cell_type","clone","clone","clone","clone_into","clone_into","clone_into","cmp","convert","convert","defaults","deserialize","deserialize","deserialize","div","div","div","eq","eq","eq","equivalent","equivalent","error","fill","fill_with","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from_iter","from_iter","from_str","get","get","into","into","into","into","into_cell_value","into_iter","into_iter","is_empty","is_integral","is_signed","is_zero","iter","len","max","min","minmax","mul","mul","mul","neg","neg","neg","new","new","next","one","one","partial_cmp","partial_cmp","put","serialize","serialize","serialize","size_of","static_cast","static_cast","sub","sub","sub","to_f64","to_i64","to_owned","to_owned","to_owned","to_string","to_u64","to_vec","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","unify","union","with_ct","zero","zero","Error","ExpectedError","NarrowingError","ParseError","Result","borrow","borrow_mut","fmt","fmt","from","into","to_string","try_from","try_into","type_id","dst","src"],"q":[[0,"erased_cells"],[154,"erased_cells::error"],[169,"erased_cells::error::Error"]],"d":["Buffer variants for each <code>CellType</code>","","Trait for marking Rust primitives as having a …","Cell-type variants","Value variants for each <code>CellType</code>","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Determine of <code>self</code> can fit within <code>other</code>.","Returns the <code>CellType</code> covering <code>Self</code>.","Get the cell type of the encoded values.","Get the <code>CellType</code> encoding <code>self</code>.","","","","","","","","","Convert <code>self</code> into a variant with <code>CellType</code> <code>cell_type</code> equal …","","","","","","","","","","","","","","Create a buffer of size <code>len</code> with all values <code>value</code>.","Fill a buffer of size <code>len</code> with values from a closure.","","","","","Returns the argument unchanged.","","Returns the argument unchanged.","","Returns the argument unchanged.","","Returns the argument unchanged.","","","","Panics of <code>idx</code> is outside of <code>[0, len())</code>.","Get the <code>CellValue</code> contents as a <code>T</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Converts <code>self</code> into a <code>CellValue</code>.","","","Determine if the buffer has zero values in it.","Determine if <code>self</code> is integral or floating-point.","Determine if <code>self</code> is signed or unsigned.","","Get an iterator over all the valid enumeration values.","Get the length of the buffer.","Determine the maximum value that can be represented by <code>self</code>…","Determine the minimum value that can be represented by <code>self</code>…","","","","","","","","","Construct new <code>CellValue</code> from a statically known …","","Construct the one value for a variant.","","","","","","","","Number of bytes needed to encode <code>self</code>.","Convert dynamic type to static type when logically known. …","Convert dynamic type to static type when logically known. …","","","","","","","","","","","","","","","","","","","","","","","","Determines the smallest cell type that can contain <code>self</code> …","Select the <code>CellType</code> that can numerically contain both <code>self</code> …","A callback style macro used to construct various …","Construct the zero value for a variant.","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,0,0,0,0,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,1,2,19,1,3,2,19,1,3,2,3,12,1,2,1,3,2,1,3,2,2,1,2,1,1,3,2,1,1,2,1,3,2,3,2,0,1,1,1,3,3,2,19,1,1,1,3,2,2,1,1,3,1,2,19,1,3,2,12,19,1,1,3,3,2,3,1,3,3,1,1,1,2,1,1,2,1,2,19,3,2,1,2,1,1,3,2,3,12,12,1,1,2,2,2,1,3,2,3,2,1,19,1,3,2,19,1,3,2,19,1,3,2,2,3,0,3,2,0,27,27,27,0,27,27,27,27,27,27,27,27,27,27,28,28],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[1,1]],[[1,1]],[[2,2]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[3,3],4],[[],3],[1,3],[2,3],[1,1],[3,3],[2,2],[[]],[[]],[[]],[[2,2],5],[[1,3],[[6,[1]]]],[[2,3],[[6,[2]]]],[[7,3],1],[8,[[9,[1]]]],[8,[[9,[3]]]],[8,[[9,[2]]]],[[1,1]],[[1,1]],[[2,2]],[[1,1],4],[[3,3],4],[[2,2],4],[[],4],[[],4],0,[[2,7],1],[7,1],[[1,10],11],[[3,10],11],[[3,10],11],[[2,10],11],[[]],[[[13,[12]]],1],[[]],[[[14,[12]]],1],[[]],[12,2],[[]],[15,1],[15,1],[16,[[9,[3]]]],[[1,7],2],[2,[[6,[12]]]],[[]],[[]],[[]],[[]],[[],2],[[]],[1],[1,4],[3,4],[3,4],[2,4],[[],17],[1,7],[3,2],[3,2],[1],[[1,1]],[[1,1]],[[2,2]],[1],[1],[2],[[[13,[12]]],1],[[[0,[12,18]]],2],[19,20],[3,2],[[],2],[[1,1],[[20,[5]]]],[[2,2],[[20,[5]]]],[[1,7,2],6],[[1,21],9],[[3,21],9],[[2,21],9],[3,7],[[[0,[12,18]]],20],[[[0,[12,18]]],20],[[1,1]],[[1,1]],[[2,2]],[2,[[20,[22]]]],[2,[[20,[23]]]],[[]],[[]],[[]],[[],24],[2,[[20,[25]]]],[1,[[6,[[13,[12]]]]]],[[],9],[[],9],[[],9],[[],9],[[],9],[[],9],[[],9],[[],9],[[],26],[[],26],[[],26],[[],26],[[2,2]],[[3,3],3],0,[3,2],[[],2],0,0,0,0,0,[[]],[[]],[[27,10],11],[[27,10],11],[[]],[[]],[[],24],[[],9],[[],9],[[],26],0,0],"c":[],"p":[[4,"CellBuffer"],[4,"CellValue"],[4,"CellType"],[15,"bool"],[4,"Ordering"],[6,"Result"],[15,"usize"],[8,"Deserializer"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"CellEncoding"],[3,"Vec"],[15,"slice"],[8,"IntoIterator"],[15,"str"],[8,"Iterator"],[8,"Sized"],[3,"CellBufferIterator"],[4,"Option"],[8,"Serializer"],[15,"f64"],[15,"i64"],[3,"String"],[15,"u64"],[3,"TypeId"],[4,"Error"],[13,"NarrowingError"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
