var searchIndex = JSON.parse('{\
"erased_cells":{"doc":"Encoding and manipulation of runtime-dynamic cell values.","t":"IEDIEENNNNNNNNNNNNNNNNNNNIDDDENNNNNNNNNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKKLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLALLLKLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLKLLLLLLLLLLLLLLLLKLLLLLKLLLLLLLLLLKLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLOKLLLLNENNNNGLLLLLLLLLLLMM","n":["BufferOps","CellBuffer","CellBufferIterator","CellEncoding","CellType","CellValue","Default","Float32","Float32","Float32","Float64","Float64","Float64","Int16","Int16","Int16","Int32","Int32","Int32","Int64","Int64","Int64","Int8","Int8","Int8","IsNodata","Mask","MaskedCellBuffer","MaskedCellBufferIterator","NoData","None","UInt16","UInt16","UInt16","UInt32","UInt32","UInt32","UInt64","UInt64","UInt64","UInt8","UInt8","UInt8","Value","add","add","add","add","add","add","add","add","add","add","all","bitand","bitand","bitor","bitor","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","buffer","buffer_mut","can_fit_into","cell_type","cell_type","cell_type","cell_type","cell_type","clone","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","cmp","cmp","cmp","cmp","convert","convert","convert","convert","counts","counts","default","default","deserialize","deserialize","deserialize","deserialize","deserialize","div","div","div","div","div","div","div","div","div","div","eq","eq","eq","eq","eq","eq","equivalent","equivalent","equivalent","equivalent","error","extend","extend","extend","fill","fill","fill","fill","fill_via","fill_via","fill_via","fill_via","fill_with_mask_via","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from_iter","from_iter","from_iter","from_iter","from_str","from_vec","from_vec","from_vec","from_vec_with_nodata","get","get","get","get","get","get_masked","get_with_mask","index","index_mut","into","into","into","into","into","into","into","into","into_cell_value","into_iter","into_iter","into_iter","into_iter","into_iter","is","is","is","is_empty","is_empty","is_empty","is_integral","is_signed","is_zero","iter","iter_mut","len","len","len","len","mask","mask_mut","max_value","min_max","min_max","min_max","min_value","mul","mul","mul","mul","mul","mul","mul","mul","mul","mul","neg","neg","neg","neg","neg","new","new","new","new","next","next","not","not","one","one","partial_cmp","partial_cmp","partial_cmp","partial_cmp","partial_cmp","put","put","put","put","put_with_mask","serialize","serialize","serialize","serialize","serialize","size_of","static_cast","static_cast","sub","sub","sub","sub","sub","sub","sub","sub","sub","sub","to_f64","to_i64","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_u64","to_vec","to_vec","to_vec","to_vec_with_nodata","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","unify","union","value","with_ct","with_defaults","with_defaults","with_defaults","zero","zero","Err","Error","ExpectedError","NarrowingError","Ok","ParseError","Result","borrow","borrow_mut","eq","fmt","fmt","from","into","to_string","try_from","try_into","type_id","dst","src"],"q":[[0,"erased_cells"],[318,"erased_cells::error"],[336,"erased_cells::error::Error"],[338,"core::convert"],[339,"core::clone"],[340,"core::cmp"],[341,"core::marker"],[342,"core::result"],[343,"serde::de"],[344,"core::cmp"],[345,"core::ops::function"],[346,"core::fmt"],[347,"core::fmt"],[348,"core::option"],[349,"core::iter::traits::iterator"],[350,"serde::ser"],[351,"alloc::string"],[352,"core::any"]],"d":["Operations common to buffers of <code>CellValue</code>s.","An enum over buffers of <code>CellEncoding</code> types.","Iterator over <code>CellValue</code> elements in a <code>CellBuffer</code>.","Trait for marking Rust primitives as having a …","Cell-type variants","Value variants for each <code>CellType</code>","Case where there the default no-data value should be used.","","","","","","","","","","","","","","","","","","","Trait for no-data testing.","Encodes the bit-mask for <code>MaskedCellBuffer</code>","A <code>CellBuffer</code> with a companion <code>Mask</code>.","Iterator over (<code>CellValue</code>, <code>bool</code>) elements in a …","Encodes a no-data value for cells that should be …","Case where there is no no-data value.","","","","","","","","","","","","","Case where a specific no-data value is specified.","","","","","","","","","","","Determine if all mask values equal <code>value</code>.","","","","","","","","","","","","","","","","","","","","","","","Determine of <code>self</code> can fit within <code>other</code>.","Returns the <code>CellType</code> covering <code>Self</code>.","Get the cell type of the encoded value.","","","Get the <code>CellType</code> encoding <code>self</code>.","","","","","","","","","","","","","","","","","Create a new <code>CellBuffer</code> whereby all <code>CellValue</code>s are …","","","Convert <code>self</code> into a variant with <code>CellType</code> <code>cell_type</code> equal …","Returns a tuple of representing counts of <code>(data, nodata)</code>.","Returns a tuple of representing counts of <code>(data, nodata)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","Crate-wide <code>Result</code>/<code>Error</code> types.","","","","Create a buffer of size <code>len</code> with all values <code>value</code>.","","Create a mask of size <code>len</code> with all values set to <code>value</code>.","","Fill a buffer of size <code>len</code> with values from a closure.","","Create a mask of size <code>len</code> were each value is determined by …","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","Returns the argument unchanged.","","Returns the argument unchanged.","Returns the argument unchanged.","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","Construct a <code>CellBuffer</code> from a <code>Vec&lt;T&gt;</code>.","","","Constructs a <code>MaskedCellBuffer</code> from a <code>Vec&lt;CellEncoding&gt;</code>, …","Get the <code>CellValue</code> at index <code>idx</code>.","","Get the mask value at position <code>index</code>.","","Get the <code>CellValue</code> contents as a <code>T</code>.","Get a buffer value at position <code>index</code> with mask evaluated.","Get the cell value and mask value at position <code>index</code>.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Converts <code>self</code> into a <code>CellValue</code>.","","","","","","Determines if the <code>self</code> matches given <code>NoData</code> value.","Determines if <code>value</code> should be considered a “no-data” …","","Determine if the buffer has zero values in it.","","Returns <code>true</code> if <code>self.len() == 0</code>.","Determine if <code>self</code> is integral or floating-point.","Determine if <code>self</code> is signed or unsigned.","","Get an iterator over all the valid enumeration values.","Gets an mutable iterator over values in mask, in sequence.","Get the length of the buffer.","","Get the number of mask elements.","","","","Determine the maximum value that can be represented by <code>self</code>…","Compute the minimum and maximum values the buffer.","","","Determine the minimum value that can be represented by <code>self</code>…","","","","","","","","","","","","","","","","Create a new mask containing <code>values</code>.","Create a new combined <code>CellBuffer</code> and <code>Mask</code>.","","Construct new <code>CellValue</code> from a statically known …","","","","","Construct the one value for a variant.","","","","","","","Store <code>value</code> at position <code>idx</code>.","","Set the mask value at position <code>index</code> to <code>value</code>.","","Set the <code>value</code> and <code>mask</code> at position <code>index</code>.","","","","","","Number of bytes needed to encode <code>self</code>.","Convert dynamic type to static type when logically known. …","Convert dynamic type to static type when logically known. …","","","","","","","","","","","","","","","","","","","","","Convert <code>self</code> into a <code>Vec&lt;T&gt;</code>.","","Converts <code>self</code> to <code>Vec&lt;T&gt;</code>, ignoring the <code>mask</code> values.","Convert <code>self</code> into a <code>Vec&lt;T&gt;</code>, replacing values where the …","","","","","","","","","","","","","","","","","","","","","","","","","Determines the smallest cell type that can contain <code>self</code> …","Select the <code>CellType</code> that can numerically contain both <code>self</code> …","","A callback style macro used to construct various …","Construct a <code>CellBuffer</code> of given <code>len</code> length and <code>ct</code> <code>CellType</code>","","","Construct the zero value for a variant.","","Contains the error value","Enumeration of error kinds","","","Contains the success value","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,0,0,0,0,0,8,1,7,2,1,7,2,1,7,2,1,7,2,1,7,2,1,7,2,0,0,0,0,0,8,1,7,2,1,7,2,1,7,2,1,7,2,8,1,1,1,1,4,4,4,4,2,2,5,5,5,5,5,29,30,1,7,5,4,8,2,29,30,1,7,5,4,8,2,4,4,7,10,38,1,4,2,1,7,5,4,8,2,1,7,5,4,8,2,1,7,5,2,38,1,4,2,5,4,5,8,1,7,5,4,2,1,1,1,1,4,4,4,4,2,2,1,7,5,4,8,2,1,7,5,2,0,1,5,4,38,1,5,4,38,1,5,4,4,1,7,7,5,4,8,2,29,30,1,1,1,7,5,4,4,8,2,2,1,1,4,4,7,38,1,4,4,38,1,5,4,2,4,4,5,5,29,30,1,7,5,4,8,2,10,29,30,1,5,4,39,8,2,38,1,5,7,7,2,7,5,38,1,5,4,4,4,7,38,1,4,7,1,1,1,1,4,4,4,4,2,2,1,1,4,4,2,5,4,8,2,29,30,5,5,7,2,1,7,5,4,2,38,1,5,4,4,1,7,5,4,2,7,10,10,1,1,1,1,4,4,4,4,2,2,2,2,1,7,5,4,8,2,7,2,38,1,4,4,29,30,1,7,5,4,8,2,29,30,1,7,5,4,8,2,29,30,1,7,5,4,8,2,2,7,8,0,38,1,4,7,2,13,0,37,37,13,37,0,37,37,37,37,37,37,37,37,37,37,37,40,40],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[1,1]],[[1,-1],[],[[3,[2]]]],[[1,1]],[[1,1]],[[4,4]],[[4,4]],[[4,-1],[],[[3,[2]]]],[[4,4]],[[2,-1],[],[[3,[2]]]],[[2,-1],[],[[3,[2]]]],[[5,6],6],[[5,5]],[[5,5]],[[5,5]],[[5,5]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[4,1],[4,1],[[7,7],6],[[],7],[-1,7,[]],[1,7],[4,7],[2,7],[1,1],[7,7],[5,5],[4,4],[[[8,[-1]]],[[8,[-1]]],[9,10]],[2,2],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[1,1],12],[[7,7],12],[[5,5],12],[[2,2],12],[[-1,7],[[13,[-1]]],14],[[1,7],[[13,[1]]]],[[4,7],[[13,[4]]]],[[2,7],[[13,[2]]]],[5,[[11,[15,15]]]],[4,[[11,[15,15]]]],[[],5],[[],[[8,[-1]]],10],[-1,[[16,[1]]],17],[-1,[[16,[7]]],17],[-1,[[16,[5]]],17],[-1,[[16,[4]]],17],[-1,[[16,[2]]],17],[[1,-1],[],[[3,[2]]]],[[1,1]],[[1,1]],[[1,1]],[[4,4]],[[4,4]],[[4,-1],[],[[3,[2]]]],[[4,4]],[[2,-1],[],[[3,[2]]]],[[2,-1],[],[[3,[2]]]],[[1,1],6],[[7,7],6],[[5,5],6],[[4,4],6],[[[8,[-1]],[8,[-1]]],6,[18,10]],[[2,2],6],[[-1,-2],6,[],[]],[[-1,-2],6,[],[]],[[-1,-2],6,[],[]],[[-1,-2],6,[],[]],0,[[1,-1],11,19],[[5,-1],11,19],[[4,-1],11,19],[[15,2],-1,[]],[[15,2],1],[[15,6],5],[[15,2],4],[[15,-1],-2,20,[]],[[15,-1],1,20],[[15,-1],5,20],[[15,-1],4,20],[[15,-1],4,20],[[1,21],22],[[7,21],22],[[7,21],22],[[5,21],22],[[4,21],22],[[[8,[-1]],21],22,[23,10]],[[2,21],22],[-1,-1,[]],[-1,-1,[]],[[[24,[-1]]],1,10],[-1,-1,[]],[[[25,[-1]]],1,10],[-1,-1,[]],[-1,-1,[]],[1,4],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,2,10],[-1,1,19],[-1,1,19],[-1,4,19],[-1,4,19],[26,[[16,[7]]]],[[[25,[-1]]],-2,10,[]],[[[25,[-1]]],1,10],[[[25,[-1]]],4,10],[[[25,[-1]],[8,[-1]]],4,10],[[-1,15],2,[]],[[1,15],2],[[5,15],6],[[4,15],2],[2,[[13,[-1]]],10],[[4,15],[[27,[2]]]],[[4,15],[[11,[2,6]]]],[[5,15]],[[5,15]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,2,[]],[-1,-2,[],[]],[-1,-2,[],[]],[1],[5],[4],[[-1,[8,[-2]]],6,[],10],[[[8,[-1]],2],6,10],[[2,[8,[-1]]],6,10],[-1,6,[]],[1,6],[5,6],[7,6],[7,6],[2,6],[[],[[0,[28]]]],[5,[[0,[28]]]],[-1,15,[]],[1,15],[5,15],[4,15],[4,5],[4,5],[7,2],[-1,[[11,[2,2]]],[]],[1,[[11,[2,2]]]],[4,[[11,[2,2]]]],[7,2],[[1,1]],[[1,1]],[[1,-1],[],[[3,[2]]]],[[1,1]],[[4,-1],[],[[3,[2]]]],[[4,4]],[[4,4]],[[4,4]],[[2,-1],[],[[3,[2]]]],[[2,-1],[],[[3,[2]]]],[1],[1],[4],[4],[2],[[[25,[6]]],5],[[1,5],4],[-1,[[8,[-1]]],10],[-1,2,[10,14]],[29,27],[30,27],[5],[5],[7,2],[[],2],[[1,1],[[27,[12]]]],[[7,7],[[27,[12]]]],[[5,5],[[27,[12]]]],[[4,4],[[27,[12]]]],[[2,2],[[27,[12]]]],[[-1,15,2],[[13,[11]]],[]],[[1,15,2],[[13,[11]]]],[[5,15,6],11],[[4,15,2],[[13,[11]]]],[[4,15,2,6],[[13,[11]]]],[[1,-1],16,31],[[7,-1],16,31],[[5,-1],16,31],[[4,-1],16,31],[[2,-1],16,31],[7,15],[-1,[[27,[-2]]],[10,14],[]],[-1,[[27,[-2]]],[10,14],[]],[[1,-1],[],[[3,[2]]]],[[1,1]],[[1,1]],[[1,1]],[[4,4]],[[4,4]],[[4,4]],[[4,-1],[],[[3,[2]]]],[[2,-1],[],[[3,[2]]]],[[2,-1],[],[[3,[2]]]],[2,[[27,[32]]]],[2,[[27,[33]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,34,[]],[2,[[27,[35]]]],[-1,[[13,[[25,[-2]]]]],[],10],[1,[[13,[[25,[-1]]]]],10],[4,[[13,[[25,[-1]]]]],10],[[4,[8,[-1]]],[[13,[[25,[-1]]]]],10],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,36,[]],[-1,36,[]],[-1,36,[]],[-1,36,[]],[-1,36,[]],[-1,36,[]],[-1,36,[]],[-1,36,[]],[[2,2],[[11,[2,2]]]],[[7,7],7],[[[8,[-1]]],[[27,[-1]]],10],0,[[15,7],-1,[]],[[15,7],1],[[15,7],4],[7,2],[[],2],0,0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[37,37],6],[[37,21],22],[[37,21],22],[-1,-1,[]],[-1,-2,[],[]],[-1,34,[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,36,[]],0,0],"c":[],"p":[[4,"CellBuffer",0],[4,"CellValue",0],[8,"Into",338],[3,"MaskedCellBuffer",0],[3,"Mask",0],[15,"bool"],[4,"CellType",0],[4,"NoData",0],[8,"Clone",339],[8,"CellEncoding",0],[15,"tuple"],[4,"Ordering",340],[6,"Result",318],[8,"Sized",341],[15,"usize"],[4,"Result",342],[8,"Deserializer",343],[8,"PartialEq",340],[8,"IntoIterator",344],[8,"Fn",345],[3,"Formatter",346],[6,"Result",346],[8,"Debug",346],[15,"slice"],[3,"Vec",347],[15,"str"],[4,"Option",348],[8,"Iterator",349],[3,"CellBufferIterator",0],[3,"MaskedCellBufferIterator",0],[8,"Serializer",350],[15,"f64"],[15,"i64"],[3,"String",351],[15,"u64"],[3,"TypeId",352],[4,"Error",318],[8,"BufferOps",0],[8,"IsNodata",0],[13,"NarrowingError",336]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
