var searchIndex = JSON.parse('{\
"erased_cells":{"doc":"Encoding and manipulation of runtime-dynamic cell values.","t":"EDIEENNNNNNNNNNNNNNNNNNNNNNNNNNNNNNLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLALLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLENNNGLLLLLLLLLLMM","n":["CellBuffer","CellBufferIterator","CellEncoding","CellType","CellValue","Float32","Float32","Float32","Float64","Float64","Float64","Int16","Int16","Int16","Int32","Int32","Int32","Int64","Int64","Int64","Int8","Int8","Int8","UInt16","UInt16","UInt16","UInt32","UInt32","UInt32","UInt64","UInt64","UInt64","UInt8","UInt8","UInt8","add","add","add","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","can_fit_into","cell_type","cell_type","cell_type","clone","clone","clone","clone_into","clone_into","clone_into","cmp","convert","convert","defaults","div","div","div","eq","eq","eq","equivalent","equivalent","error","fill","fill_with","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from_iter","from_iter","from_str","get","get","into","into","into","into","into_cell_value","into_iter","into_iter","is_empty","is_integral","is_signed","is_zero","iter","len","max","min","minmax","mul","mul","mul","neg","neg","neg","new","new","next","one","one","partial_cmp","partial_cmp","put","size_of","static_cast","static_cast","sub","sub","sub","to_f64","to_i64","to_owned","to_owned","to_owned","to_string","to_u64","to_vec","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","unify","union","zero","zero","Error","ExpectedError","NarrowingError","ParseError","Result","borrow","borrow_mut","fmt","fmt","from","into","to_string","try_from","try_into","type_id","dst","src"],"q":[[0,"erased_cells"],[147,"erased_cells::error"],[162,"erased_cells::error::Error"]],"d":["Buffer variants for each <code>CellType</code>","","Trait for marking Rust primitives as having a …","Cell-type variants","Value variants for each <code>CellType</code>","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Determine of <code>self</code> can fit within <code>other</code>.","Returns the <code>CellType</code> covering <code>Self</code>.","Get the cell type of the encoded values.","Get the <code>CellType</code> encoding <code>self</code>.","","","","","","","","","Convert <code>self</code> into a variant with <code>CellType</code> <code>cell_type</code> equal …","","","","","","","","","","","Create a buffer of size <code>len</code> with all values <code>value</code>.","Fill a buffer of size <code>len</code> with values from a closure.","","","","","Returns the argument unchanged.","","","Returns the argument unchanged.","Returns the argument unchanged.","","Returns the argument unchanged.","","","","Panics of <code>idx</code> is outside of <code>[0, len())</code>.","Get the <code>CellValue</code> contents as a <code>T</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Converts <code>self</code> into a <code>CellValue</code>.","","","Determine if the buffer has zero values in it.","Determine if <code>self</code> is integral or floating-point.","Determine if <code>self</code> is signed or unsigned.","","Get an iterator over all the valid enumeration values.","Get the length of the buffer.","Determine the maximum value that can be represented by <code>self</code>…","Determine the minimum value that can be represented by <code>self</code>…","","","","","","","","","Construct new <code>CellValue</code> from a statically known …","","Construct the one value for a variant.","","","","","Number of bytes needed to encode <code>self</code>.","Convert dynamic type to static type when logically known. …","Convert dynamic type to static type when logically known. …","","","","","","","","","","","","","","","","","","","","","","","","Determines the smallest cell type that can contain <code>self</code> …","Select the <code>CellType</code> that can numerically contain both <code>self</code> …","Construct the zero value for a variant.","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,0,0,0,0,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,1,2,18,1,3,2,18,1,3,2,3,10,1,2,1,3,2,1,3,2,2,1,2,1,1,1,2,1,3,2,3,2,0,1,1,1,3,3,2,18,1,1,1,3,2,2,1,1,3,1,2,18,1,3,2,10,18,1,1,3,3,2,3,1,3,3,1,1,1,2,1,1,2,1,2,18,3,2,1,2,1,3,10,10,1,1,2,2,2,1,3,2,3,2,1,18,1,3,2,18,1,3,2,18,1,3,2,2,3,3,2,0,25,25,25,0,25,25,25,25,25,25,25,25,25,25,26,26],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[1,1]],[[1,1]],[[2,2]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[3,3],4],[[],3],[1,3],[2,3],[1,1],[3,3],[2,2],[[]],[[]],[[]],[[2,2],5],[[1,3],[[6,[1]]]],[[2,3],[[6,[2]]]],[[7,3],1],[[1,1]],[[1,1]],[[2,2]],[[1,1],4],[[3,3],4],[[2,2],4],[[],4],[[],4],0,[[2,7],1],[7,1],[[1,8],9],[[3,8],9],[[3,8],9],[[2,8],9],[[]],[[[11,[10]]],1],[[[12,[10]]],1],[[]],[[]],[10,2],[[]],[13,1],[13,1],[14,[[15,[3]]]],[[1,7],2],[2,[[6,[10]]]],[[]],[[]],[[]],[[]],[[],2],[[]],[1],[1,4],[3,4],[3,4],[2,4],[[],16],[1,7],[3,2],[3,2],[1],[[1,1]],[[1,1]],[[2,2]],[1],[1],[2],[[[12,[10]]],1],[[[0,[10,17]]],2],[18,19],[3,2],[[],2],[[1,1],[[19,[5]]]],[[2,2],[[19,[5]]]],[[1,7,2],6],[3,7],[[[0,[10,17]]],19],[[[0,[10,17]]],19],[[1,1]],[[1,1]],[[2,2]],[2,[[19,[20]]]],[2,[[19,[21]]]],[[]],[[]],[[]],[[],22],[2,[[19,[23]]]],[1,[[6,[[12,[10]]]]]],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],24],[[],24],[[],24],[[],24],[[2,2]],[[3,3],3],[3,2],[[],2],0,0,0,0,0,[[]],[[]],[[25,8],9],[[25,8],9],[[]],[[]],[[],22],[[],15],[[],15],[[],24],0,0],"c":[],"p":[[4,"CellBuffer"],[4,"CellValue"],[4,"CellType"],[15,"bool"],[4,"Ordering"],[6,"Result"],[15,"usize"],[3,"Formatter"],[6,"Result"],[8,"CellEncoding"],[15,"slice"],[3,"Vec"],[8,"IntoIterator"],[15,"str"],[4,"Result"],[8,"Iterator"],[8,"Sized"],[3,"CellBufferIterator"],[4,"Option"],[15,"f64"],[15,"i64"],[3,"String"],[15,"u64"],[3,"TypeId"],[4,"Error"],[13,"NarrowingError"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
